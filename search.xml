<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis 笔记]]></title>
    <url>%2F2017%2F06%2F27%2F2017-06-27-mybatis%2F</url>
    <content type="text"><![CDATA[Mybatis入门单独使用jdbc编程问题总结jdbc程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Public static void main(String[] args) &#123;Connection connection = null;PreparedStatement preparedStatement = null;ResultSet resultSet = null;try &#123; //加载数据库驱动 Class.forName("com.mysql.jdbc.Driver"); //通过驱动管理类获取数据库链接 connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8", "root", "mysql"); //定义sql语句 ?表示占位符String sql = "select * from user where username = ?"; //获取预处理statement preparedStatement = connection.prepareStatement(sql); //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, "王五"); //向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //遍历查询结果集 while(resultSet.next())&#123; System.out.println(resultSet.getString("id")+" "+resultSet.getString("username")); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125;finally&#123; //释放资源 if(resultSet!=null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if(preparedStatement!=null)&#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;&#125; 上边使用jdbc的原始方法（未经封装）实现了查询数据库表记录的操作。 jdbc编程步骤： 加载数据库驱动 创建并获取数据库链接 创建jdbc statement对象 设置sql语句 设置sql语句中的参数(使用preparedStatement) 通过statement执行sql并获取结果 对sql执行结果进行解析处理 释放资源(resultSet、preparedstatement、connection) jdbc问题总结如下： 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 Sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。 对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。 MyBatis介绍MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，实质上Mybatis对ibatis进行一些改进。 MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。 Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。 Mybatis架构 mybatis配置SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。 mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。 Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。 Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。 Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程 mybatis下载mybaits的代码由github.com管理，地址：https://github.com/mybatis/mybatis-3/release mybatis-3.2.7.jar—-mybatis的核心包 lib—-mybatis的依赖包 mybatis-3.2.7.pdf—-mybatis使用手册 创建mysql数据库Mybatis入门程序第一步：创建java工程使用eclipse创建java工程 第二步：加入jar包加入mybatis核心包、依赖包、数据驱动包。 第三步：log4j.properties在classpath下创建log4j.properties如下： 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n mybatis默认使用log4j作为输出日志信息。 第四步：SqlMapConfig.xml在classpath下创建SqlMapConfig.xml，如下： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="mysql" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; SqlMapConfig.xml是mybatis核心配置文件，上边文件的配置内容为数据源、事务管理。 第五步：po类Po类作为mybatis进行sql映射使用，po类通常与数据库表对应，User.java如下： 1234567Public class User &#123; private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址get/set…… 第六步：程序编写查询映射文件在classpath下的sqlmap目录下创建sql映射文件Users.xml： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt;&lt;/mapper&gt; namespace ：命名空间，用于隔离sql语句，后面会讲另一层非常重要的作用。 在SqlMapConfig.xml中添加： 123456789&lt;!-- 根据id获取用户信息 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 自定义条件查询用户列表 --&gt; &lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; select * from user where username like &apos;%$&#123;value&#125;%&apos; &lt;/select&gt; parameterType：定义输入到sql中的映射类型，#{id}表示使用preparedstatement设置占位符号并将输入变量id传到sql。 resultType：定义结果映射类型。 加载映射文件mybatis框架需要加载映射文件，将Users.xml添加在SqlMapConfig.xml，如下： 123&lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;&lt;/mappers&gt; 测试程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Mybatis_first &#123; //会话工厂private SqlSessionFactory sqlSessionFactory;@Beforepublic void createSqlSessionFactory() throws IOException &#123; // 配置文件 String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream);&#125;// 根据 id查询用户信息@Testpublic void testFindUserById() &#123; // 数据库会话实例 SqlSession sqlSession = null; try &#123; // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 查询单个记录，根据用户id查询用户信息 User user = sqlSession.selectOne("test.findUserById", 10); // 输出用户信息 System.out.println(user); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125;// 根据用户名称模糊查询用户信息@Testpublic void testFindUserByUsername() &#123; // 数据库会话实例 SqlSession sqlSession = null; try &#123; // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 查询单个记录，根据用户id查询用户信息 List&lt;User&gt; list = sqlSession.selectList("test.findUserByUsername", "张"); System.out.println(list.size()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125;&#125; #{}和${} #{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。 ${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。 parameterType和resultType parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。 resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。 selectOne和selectListselectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常： org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3 at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70) selectList可以查询一条或多条记录。 添加映射文件：在SqlMapConfig.xml中添加： 12345678&lt;!-- 添加用户 --&gt;&lt;insert id="insertUser" parameterType="cn.itcast.mybatis.po.User"&gt;&lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 测试程序： 12345678910111213141516171819202122232425 // 添加用户信息@Testpublic void testInsert() &#123; // 数据库会话实例 SqlSession sqlSession = null; try &#123; // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 添加用户信息 User user = new User(); user.setUsername("张小明"); user.setAddress("河南郑州"); user.setSex("1"); user.setPrice(1999.9f); sqlSession.insert("test.insertUser", user); //提交事务 sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; mysql自增主键返回通过修改sql映射文件，可以将mysql自增主键返回： 12345678&lt;insert id="insertUser" parameterType="cn.itcast.mybatis.po.User"&gt; &lt;!-- selectKey将主键返回，需要再返回 --&gt; &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;);&lt;/insert&gt; 添加selectKey实现将主键返回 keyProperty:返回的主键存储在pojo中的哪个属性 order：selectKey的执行顺序，是相对与insert语句来说，由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为after resultType:返回的主键是什么类型 LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值。 Mysql使用 uuid实现主键需要增加通过select uuid()得到uuid值 12345678&lt;insert id="insertUser" parameterType="cn.itcast.mybatis.po.User"&gt;&lt;selectKey resultType="java.lang.String" order="BEFORE" keyProperty="id"&gt;select uuid()&lt;/selectKey&gt;insert into user(id,username,birthday,sex,address) values(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 注意这里使用的order是“BEFORE” Oracle使用序列生成主键首先自定义一个序列且用于生成主键，selectKey使用如下： 12345678&lt;insert id="insertUser" parameterType="cn.itcast.mybatis.po.User"&gt;&lt;selectKey resultType="java.lang.Integer" order="BEFORE" keyProperty="id"&gt;SELECT 自定义序列.NEXTVAL FROM DUAL&lt;/selectKey&gt;insert into user(id,username,birthday,sex,address) values(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 注意这里使用的order是“BEFORE” 删除映射文件：1234&lt;!-- 删除用户 --&gt;&lt;delete id="deleteUserById" parameterType="int"&gt; delete from user where id=#&#123;id&#125;&lt;/delete&gt; 测试程序：1234567891011121314151617181920// 根据id删除用户@Testpublic void testDelete() &#123; // 数据库会话实例 SqlSession sqlSession = null; try &#123; // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 删除用户 sqlSession.delete("test.deleteUserById",18); // 提交事务 sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 修改映射文件12345&lt;!-- 更新用户 --&gt;&lt;update id="updateUser" parameterType="cn.itcast.mybatis.po.User"&gt; update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt; 测试程序123456789101112131415161718192021222324252627// 更新用户信息@Testpublic void testUpdate() &#123;// 数据库会话实例SqlSession sqlSession = null;try &#123; // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 添加用户信息 User user = new User(); user.setId(16); user.setUsername("张小明"); user.setAddress("河南郑州"); user.setSex("1"); user.setPrice(1999.9f); sqlSession.update("test.updateUser", user); // 提交事务 sqlSession.commit();&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125;&#125;&#125; Mybatis解决jdbc编程的问题 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。 Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。 解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。 解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。 解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。 与hibernate不同Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 Dao开发方法 未完待续]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 教程]]></title>
    <url>%2F2017%2F06%2F13%2F2017-06-17-spring%2F</url>
    <content type="text"><![CDATA[Spring 教程简略教程,供自己忘记xml配置时，过来Ctrl + C /Ctrl + V IOC/DISpring是一个基于IOC和AOP的结构J2EE系统的框架IOC 反转控制 是Spring的基础，Inversion Of Control简单说就是创建对象由以前的程序员自己new 构造方法来调用，变成了交由Spring创建对象DI 依赖注入 Dependency Inject. 简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可 pojo准备pojo Category，用来演示IOC和DI 12345678910111213141516171819package com.xqchen.pojo; public class Category &#123; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; private int id; private String name;&#125; applicationContext.xml在src目录下新建applicationContext.xml文件applicationContext.xml是Spring的核心配置文件，通过关键字c即可获取Category对象，该对象获取的时候，即被注入了字符串”category 1“到name属性中 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!--注入的bean --&gt; &lt;bean name="c" class="com.xqchen.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt; &lt;/beans&gt; TestSpring测试代码，演示通过spring获取Category对象，以及该对象被注入的name属性。如图所示，可以打印出通过Spring拿到的Category对象的name属性 123456789101112131415161718package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.pojo.Category; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext( new String[] &#123; "applicationContext.xml" &#125;); Category c = (Category) context.getBean("c"); System.out.println(c.getName()); &#125;&#125; 原理图以获取对象的方式来进行比较 传统的方式：通过new 关键字主动创建一个对象IOC方式对象的生命周期由Spring来管理，直接从Spring那里去获取一个对象。 IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。 打个比喻：传统方式：相当于你自己去菜市场new 了一直鸡，但是是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。用 IOC：相当于去馆子(Spring)点了一直 鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。 注入对象在上例中，对Category的name属性注入了”category 1”字符串在本例中 ，对Product对象，注入一个Category对象 Product.javaProduct类中有对Category对象的setter getter1234567891011121314151617181920212223242526package com.xqchen.pojo; public class Product &#123; private int id; private String name; private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; applicationContext.xml在创建Product的时候注入一个Category对象注意，这里要使用ref来注入另一个对象 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;bean name="c" class="com.xqchen.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt; &lt;bean name="p" class="com.xqchen.pojo.Product"&gt; &lt;property name="name" value="product1" /&gt; &lt;!-- --&gt; &lt;property name="category" ref="c" /&gt; &lt;/bean&gt;&lt;/beans&gt; TestSpring通过Spring拿到的Product对象已经被注入了Category对象了 123456789101112131415161718 package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.pojo.Product; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123; "applicationContext.xml" &#125;); Product p = (Product) context.getBean("p"); System.out.println(p.getName()); System.out.println(p.getCategory().getName()); &#125;&#125; 注解方式 IOC/DI修改applicationContext.xml 添加 ```12345678910111213141516171819202122232425262728293031 表示告诉Spring要用注解的方式进行配置2. 注入对象category 注释掉，这个行为在后面将使用注解来完成```java&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt; &lt;context:annotation-config/&gt; &lt;bean name=&quot;c&quot; class=&quot;com.xqchen.pojo.Category&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;category 1&quot; /&gt; &lt;/bean&gt; &lt;bean name=&quot;p&quot; class=&quot;com.xqchen.pojo.Product&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;product1&quot; /&gt;&lt;!-- &lt;property name=&quot;category&quot; ref=&quot;c&quot; /&gt; --&gt; &lt;/bean&gt; &lt;/beans&gt; @Autowired在Product.java的category属性前加上@Autowired注解 12@Autowiredprivate Category category; 1234567891011121314151617181920212223242526272829303132333435package com.xqchen.pojo; import org.springframework.beans.factory.annotation.Autowired; public class Product &#123; private int id; private String name; @Autowired private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; 运行测试 12345678910111213141516package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.pojo.Product; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123; "applicationContext.xml" &#125;); Product p = (Product) context.getBean("p"); System.out.println(p.getName()); System.out.println(p.getCategory().getName()); &#125;&#125; @Autowired的位置除了前面的 在属性前加上@Autowired 这种方式外，也可以在setCategory方法前加上@Autowired，这样来达到相同的效果 12@Autowiredpublic void setCategory(Category category) 1234567891011121314151617181920212223242526272829303132333435package com.xqchen.pojo; import org.springframework.beans.factory.annotation.Autowired; public class Product &#123; private int id; private String name; private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; @Autowired public void setCategory(Category category) &#123; this.category = category; &#125;&#125; @Resource除了@Autowired之外，@Resource也是常用的手段 12@Resource(name="c")private Category category; 1234567891011121314151617181920212223242526272829303132333435package com.xqchen.pojo; import javax.annotation.Resource; public class Product &#123; private int id; private String name; @Resource(name="c") private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; 对Bean的注解上述例子是对注入对象行为的注解，那么bean对象本身，比如Category,Product可不可以移出applicationContext.xml配置文件，也通过注解进行呢？接下来就讲解如何对Bean进行注解配置 applicationContext.xml修改applicationContext.xml，什么都去掉，只新增： 1&lt;context:component-scan base-package="com.xqchen.pojo"/&gt; 其作用是告诉Spring，bean都放在com.xqchen.pojo这个包下 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;context:component-scan base-package="com.xqchen.pojo"/&gt; &lt;/beans&gt; @Component为Product类加上@Component注解，即表明此类是bean 12@Component("p")public class Product &#123; 为Category 类加上@Component注解，即表明此类是bean 12 @Component("c")public class Category &#123; 另外，因为配置从applicationContext.xml中移出来了，所以属性初始化放在属性声明上进行了。 12private String name="product 1";private String name="category 1"; Product.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.xqchen.pojo; import javax.annotation.Resource; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component; @Component("p")public class Product &#123; private int id; private String name="product 1"; @Autowired private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; Category.java12345678910111213141516171819202122package com.xqchen.pojo; import org.springframework.stereotype.Component; @Component("c")public class Category &#123; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; private int id; private String name="category 1";&#125; 运行测试 12345678910111213141516package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.pojo.Product; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123; "applicationContext.xml" &#125;); Product p = (Product) context.getBean("p"); System.out.println(p.getName()); System.out.println(p.getCategory().getName()); &#125;&#125; AOP 面向切面编程AOP 即 Aspect Oriental Program 面向切面编程首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务所谓的周边功能，比如性能统计，日志，事务管理等等 周边功能在Spring的变相切面编程AOP思想里，即被定义为切面 在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发 然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP 思路图 功能分两大类，辅助功能和核心业务功能 辅助功能和核心业务功能彼此独立进行开发 比如登陆功能，即便是没有性能统计和日志输出，也可以正常运行 如果有需要，就把”日志输出” 功能和 “登陆” 功能 编织在一起，这样登陆的时候，就可以看到日志输出了 辅助功能，又叫做切面，这种能够选择性的，低耦合的把切面和核心业务功能结合在一起的编程思想，就叫做切面编程 准备业务类 ProductService1234567891011package com.xqchen.service; public class ProductService &#123; public void doSomeService()&#123; System.out.println("doSomeService"); &#125; &#125; TestSpring在引入切面之前，调用该业务类 123456789101112131415package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.service.ProductService; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123; "applicationContext.xml" &#125;); ProductService s = (ProductService) context.getBean("s"); s.doSomeService(); &#125;&#125; 准备日志切面 LoggerAspect该日志切面的功能是 在调用核心功能之前和之后分别打印日志，切面就是原理图中讲的那些辅助功能。 object = joinPoint.proceed(); ```12345678910111213141516就是将来与某个核心功能编织之后，用于执行核心功能的代码```javapackage com.xqchen.aspect;import org.aspectj.lang.ProceedingJoinPoint; public class LoggerAspect &#123; public Object log(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;start log:&quot; + joinPoint.getSignature().getName()); Object object = joinPoint.proceed(); System.out.println(&quot;end log:&quot; + joinPoint.getSignature().getName()); return object; &#125;&#125; applicationContext.xml12&lt;bean name=&quot;s&quot; class=&quot;com.xqchen.service.ProductService&quot;&gt;&lt;/bean&gt; 声明业务对象 1&lt;bean id=&quot;loggerAspect&quot; class=&quot;com.xqchen.aspect.LoggerAspect&quot;/&gt; 声明日志切面 结合思路图 123&lt;aop:pointcut id=&quot;loggerCutpoint&quot; expression= &quot;execution(* com.xqchen.service.ProductService.*(..)) &quot;/&gt; 指定右边的核心业务功能 123&lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;loggerAspect&quot;&gt; &lt;aop:around pointcut-ref=&quot;loggerCutpoint&quot; method=&quot;log&quot;/&gt; &lt;/aop:aspect&gt; 指定左边的辅助功能然后通过aop:config把业务对象与辅助功能编织在一起。 1execution(* com.xqchen.service.ProductService.*(..)) 这表示对满足如下条件的方法调用，进行切面操作：返回任意类型 com.xqchen.service.ProductService.* 包名以 com.xqchen.service.ProductService 开头的类的任意方法(..) 参数是任意数量和类型 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;bean name="c" class="com.xqchen.pojo.Category"&gt; &lt;property name="name" value="yyy" /&gt; &lt;/bean&gt; &lt;bean name="p" class="com.xqchen.pojo.Product"&gt; &lt;property name="name" value="product1" /&gt; &lt;property name="category" ref="c" /&gt; &lt;/bean&gt; &lt;bean name="s" class="com.xqchen.service.ProductService"&gt; &lt;/bean&gt; &lt;bean id="loggerAspect" class="com.xqchen.aspect.LoggerAspect"/&gt; &lt;aop:config&gt; &lt;aop:pointcut id="loggerCutpoint" expression= "execution(* com.xqchen.service.ProductService.*(..)) "/&gt; &lt;aop:aspect id="logAspect" ref="loggerAspect"&gt; &lt;aop:around pointcut-ref="loggerCutpoint" method="log"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; TestSpringTestSpring 代码没有发生任何变化，通过配置的方式，把切面和核心业务类编制在了一起。 运行测试，可以发现在编织之后，业务方法运行之前和之后分别会打印日志 12345678910111213141516package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.service.ProductService; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext( new String[] &#123; "applicationContext.xml" &#125;); ProductService s = (ProductService) context.getBean("s"); s.doSomeService(); &#125;&#125; 注解方式 AOP本章节把XML方式配置AOP 改造为注解方式 注解配置业务类使用@Component(“s”) 注解ProductService 类 1234567891011package com.xqchen.service; import org.springframework.stereotype.Component; @Component("s")public class ProductService &#123; public void doSomeService()&#123; System.out.println("doSomeService"); &#125; &#125; 注解配置切面123@Aspect 注解表示这是一个切面@Component 表示这是一个bean,由Spring进行管理@Around(value = &quot;execution(* com.xqchen.service.ProductService.*(..))&quot;) 表示对com.xqchen.service.ProductService 这个类中的所有方法进行切面操作 123456789101112131415161718package com.xqchen.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component; @Aspect@Componentpublic class LoggerAspect &#123; @Around(value = "execution(* com.xqchen.service.ProductService.*(..))") public Object log(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println("start log:" + joinPoint.getSignature().getName()); Object object = joinPoint.proceed(); System.out.println("end log:" + joinPoint.getSignature().getName()); return object; &#125;&#125; applicationContext.xml去掉原有信息，添加如下3行 12&lt;context:component-scan base-package=&quot;com.xqchen.aspect&quot;/&gt;&lt;context:component-scan base-package=&quot;com.xqchen.service&quot;/&gt; 扫描包com.xqchen.aspect和com.xqchen.service，定位业务类和切面类```123456789101112131415161718192021222324找到被注解了的切面类，进行切面配置```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.xqchen.aspect&quot;/&gt; &lt;context:component-scan base-package=&quot;com.xqchen.service&quot;/&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; 运行测试 SPRING MVC待更新 注解方式测试jar注解方式用到了junit,所以需要下载:junit-4.12.jar和hamcrest-all-1.3.jar并导入到当前项目中。 TestSpring修改TestSpring, 并运行 @RunWith(SpringJUnit4ClassRunner.class)表示这是一个Spring的测试类 @ContextConfiguration(“classpath:applicationContext.xml”)定位Spring的配置文件 @Autowired给这个测试类装配Category对象 @Test测试逻辑，打印c对象的名称 123456789101112131415161718192021package com.xqchen.test; import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.xqchen.pojo.Category; @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class TestSpring &#123; @Autowired Category c; @Test public void test()&#123; System.out.println(c.getName()); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用maven创建web项目]]></title>
    <url>%2F2017%2F06%2F05%2F2017-06-05-002%2F</url>
    <content type="text"><![CDATA[首先新建一个maven项目，看图： ##按照以上步骤就可以创建一个maven项目，可以看到最下图的目录结构**，但是这样的目录结构是不对的，需要做一些修改。 首先为了避免乱码，我们应该将项目编码换成UTF-8，以后项目编码都采用UTF-8，加个字符编码过滤器，乱码就不再“乱”了（不表示没有，但是比较容易解决）。 再次，按照以下图解来进行操作（设置JRE为默认的），这样就会出现完整的、正确的目录结构 最后，还有个index.jsp报错，我们需要引入Java ee的jar包即可。在pom.xml中引入： 123456&lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; 至此，完整的目录结构以及正确的项目搞定了。接下来再进行一些配置，毕竟是web项目，需要jstl等等，配置如下： 注: 如果报错 cannot change version web module 3.0 请参阅 百度经验]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 三种实例化bean的方式]]></title>
    <url>%2F2017%2F06%2F05%2F2017-06-05-001%2F</url>
    <content type="text"><![CDATA[在spring中有三中实例化bean的方式： 使用构造器实例化；(通常使用的一个方法) 使用静态工厂方法实例化； 使用实例化工厂方法实例化。 使用构造器实例化当你使用构造方法来创建bean的时候，Spring对class没有特殊的要求。也就是说，正在开发的类不需要实现任何特定的接口或者以特定的方式进行编码。但是，根据你使用那种类型的IoC来指定bean，你可能需要一个默认（无参）的构造方法。 Spring IoC 容器可以管理几乎所有你想让它管理的类，它不限于管理POJO。大多数Spring用户更喜欢使用POJO（一个默认无参的构造方法和setter,getter方法）。但在容器中使用非bean形式(non-bean style)的类也是可以的。比如遗留系统中的连接池，很显然它与JavaBean规范不符，但Spring也能管理它。 当使用基于XML的元数据配置文件，可以这样来指定bean类：123&lt;!--spring.xml配置：--&gt; &lt;bean id="exampleBean" class="examples.ExampleBean"/&gt; id是对象的名称，class是要实例化的类，然后再通过正常的方式进调用实例化的类即可，例如： 12345678public void ExampleBean()&#123; //加载spring配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(new String[]&#123;"/conf/spring.xml"&#125;); //调用getBean方法取得被实例化的对象。 exampleBean eb = (exampleBean) ac.getBean("exampleBean"); eb.save(); &#125; 采用这种实例化方式要注意的是：要实例化的类中如果有构造器的话，一定要有一个无参的构造器。 使用静态工厂方法实例化使用静态工厂方法进行实例化就要具备两个条件： 要有工厂类及其工厂方法； 工厂方法是静态的。 首先创建工程类及其静态方法： 12345678public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125;&#125; 然后再去配置spring配置文件：当采用静态工厂方法创建bean时，除了需要指定class属性外，还需要通过factory-method属性来指定创建bean实例的工厂方法。Spring将调用此方法(其可选参数接下来介绍)返回实例对象，就此而言，跟通过普通构造器创建类实例没什么两样。 下面的bean定义展示了如何通过工厂方法来创建bean实例。注意，此定义并未指定返回对象的类型，仅指定该类包含的工厂方法。在此例中，createInstance()必须是一个static方法。 1&lt;bean id="clientService" class="examples.ClientService" factory-method="createInstance"/&gt; 注: id是实例化的对象的名称，class是工厂类，也就实现实例化类的静态方法所属的类，factory-method是实现实例化类的静态方法。 然后按照正常的调用方法去调用即可： 使用实例化工厂方法实例化与通过 静态工厂方法 实例化类似，通过调用工厂实例的非静态方法进行实例化。 使用这种方式时，class属性必须为空，而factory-bean属性必须指定为当前(或其祖先)容器中包含工厂方法的bean的名称，而该工厂bean的工厂方法本身必须通过factory-method属性来设定。123456789&lt;!-- 工厂bean，包含createInstance()方法 --&gt;&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- 其他需要注入的依赖项 --&gt;&lt;/bean&gt;&lt;!-- 通过工厂bean创建的ben --&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt; 123456789public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private DefaultServiceLocator() &#123;&#125; public ClientService createClientServiceInstance() &#123; return clientService; &#125;&#125; 一个工厂类也可以有多个工厂方法，如下代码所示：1234567891011&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- 其他需要注入的依赖项 --&gt;&lt;/bean&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt;&lt;bean id="accountService" factory-bean="serviceLocator" factory-method="createAccountServiceInstance"/&gt; 12345678910111213141516public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); private DefaultServiceLocator() &#123;&#125; public ClientService createClientServiceInstance() &#123; return clientService; &#125; public AccountService createAccountServiceInstance() &#123; return accountService; &#125;&#125; 这种做法表明工厂bean本身也可以通过依赖注入（DI）进行管理配置。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从为什么 String=String 谈到 StringBuilder 和 StringBuffer]]></title>
    <url>%2F2017%2F06%2F04%2F2017-06-04-001%2F</url>
    <content type="text"><![CDATA[前言有这么一段代码：123456789public class TestMain&#123; public static void main(String[] args) &#123; String str0 = "123"; String str1 = "123"; System.out.println(str0 == str1); &#125;&#125; 运行结果是什么？答案当然是true。对，答案的确是true，但是这是为什么呢？很多人第一反应肯定是两个”123″的String当然相等啊，这还要想。但是”==”在Java比较的不是两个对象的值，而是比较两个对象的引用是否相等，和两个String都是”123″又有什么关系呢？或者我们把程序修改一下123456789public class TestMain&#123; public static void main(String[] args) &#123; String str2 = new String("234"); String str3 = new String("234"); System.out.println(str2 == str3); &#125;&#125; 这时候运行结果就是false了，因为尽管两个String对象都是”234″，但是str2和str3是两个不同的引用，所以返回的false。OK，围绕第一段代码返回true，第二段代码返回false，开始文章的内容。 为什么String=String？在JVM中有一块区域叫做常量池，关于常量池，可以参考这篇文章：Java内存区域及对象常量池中的数据是那些在编译期间被确定，并被保存在已编译的.class文件中的一些数据。除了包含所有的8种基本数据类型（char、byte、short、int、long、float、double、boolean）外，还有String及其数组的常量值，另外还有一些以文本形式出现的符号引用。 Java栈的特点是存取速度快（比堆块），但是空间小，数据生命周期固定，只能生存到方法结束。我们定义的 boolean b = true、char c = ‘c’、String str = “123” ，这些语句，我们拆分为几部分来看： true、c、123，这些等号右边的指的是编译期间可以被确定的内容，都被维护在常量池中 b、c、str这些等号左边第一个出现的指的是一个引用，引用的内容是等号右边数据在常量池中的地址 boolean、char、String这些是引用的类型 栈有一个特点，就是数据共享。回到我们第一个例子，第五行String str0 = “123″，编译的时候，在常量池中创建了一个常量”123″，然后走第六行String str1 = “123″，先去常量池中找有没有这个”123″，发现有，str1也指向常量池中的”123″，所以第七行的str0 == str1返回的是true，因为str0和str1指向的都是常量池中的”123″这个字符串的地址。当然如果String str1 = “234″，就又不一样了，因为常量池中没有”234″，所以会在常量池中创建一个”234″，然后str1代表的是这个”234″的地址。分析了String，其实其他基本数据类型也都是一样的：先看常量池中有没有要创建的数据，有就返回数据的地址，没有就创建一个。 第二个例子呢？Java虚拟机的解释器每遇到一个new关键字，都会在堆内存中开辟一块内存来存放一个String对象，所以str2、str3指向的堆内存中虽然存储的是相等的”234″，但是由于是两块不同的堆内存，因此str2 == str3返回的仍然是false，网上找到一张图表示一下这个概念： 为什么要使用StringBuilder和StringBuffer拼接字符串？ 大家在开发中一定有一个原则是”利用StringBuilder和StringBuffer拼接字符串”，但是为什么呢？用一段代码来分析一下： 123456789 public class StringTest &#123; @Test public void testStringPlus() &#123; String str = "111"; str += "222"; str += "333"; System.out.println(str); &#125; &#125; 这段代码，我们找到编译后的StringTest.class文件，使用”javap -verbose StringTest”或者”javap -c StringTest”都可以，反编译一下class获取到对应的字节码： 123456789101112131415161718192021222324252627 public void testStringPlus(); Code: 0: ldc #2 // String 111 2: astore_1 3: new #3 // class java/lang/StringBuilder 6: dup 7: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 10: aload_1 11: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 14: ldc #6 // String 222 16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokevirtual #7 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 22: astore_1 23: new #3 // class java/lang/StringBuilder 26: dup 27: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 30: aload_1 31: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 34: ldc #8 // String 333 36: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 39: invokevirtual #7 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 42: astore_1 43: getstatic #9 // Field java/lang/System.out:Ljava/io/PrintStream; 46: aload_1 47: invokevirtual #10 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 50: return&#125; 这段字节码不用看得很懂，大致上能明白就好，意思很明显：编译器每次碰到”+”的时候，会new一个StringBuilder出来，接着调用append方法，在调用toString方法，生成新字符串。那么，这意味着，如果代码中有很多的”+”，就会每个”+”生成一次StringBuilder，这种方式对内存是一种浪费，效率很不好。 在Java中还有一种拼接字符串的方式，就是String的concat方法，其实这种方式拼接字符串也不是很好，具体原因看一下concat方法的实现： 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);&#125; 意思就是通过两次字符串的拷贝，产生一个新的字符数组buf[]，再根据字符数组buf[]，new一个新的String对象出来，这意味着concat方法调用N次，将发生N*2次数组拷贝以及new出N个String对象，无论对于时间还是空间都是一种浪费。 根据上面的解读，由于”+”拼接字符串与String的concat方法拼接字符串的低效，我们才需要使用StringBuilder和StringBuffer来拼接字符串。以StringBuilder为例：123456789101112public class TestMain&#123; public static void main(String[] args) &#123; StringBuilder sb = new StringBuilder("111"); sb.append("222"); sb.append("111"); sb.append("111"); sb.append("444"); System.out.println(sb.toString()); &#125;&#125; StringBuffer和StringBuilder原理一样，无非是在底层维护了一个char数组，每次append的时候就往char数组里面放字符而已，在最终sb.toString()的时候，用一个new String()方法把char数组里面的内容都转成String，这样，整个过程中只产生了一个StringBuilder对象与一个String对象，非常节省空间。StringBuilder唯一的性能损耗点在于char数组不够的时候需要进行扩容，扩容需要进行数组拷贝，一定程度上降低了效率。 StringBuffer和StringBuilder用法一模一样，唯一的区别只是StringBuffer是线程安全的，它对所有方法都做了同步，StringBuilder是线程非安全的，所以在不涉及线程安全的场景，比如方法内部，尽量使用StringBuilder，避免同步带来的消耗。 另外，StringBuffer和StringBuilder还有一个优化点，上面说了，扩容的时候有性能上的损耗，那么如果可以估计到要拼接的字符串的长度的话，尽量利用构造函数指定他们的长度。 真的不能用”+”拼接字符串？虽然说不要用”+”拼接字符串，因为会产生大量的无用StringBuilder对象，但也不是不可以，比如可以使用以下的方式： 12345678public class TestMain&#123; public static void main(String[] args) &#123; String str = "111" + "222" + "333" + "444"; System.out.println(str); &#125;&#125; 就这种连续+的情况，实际上编译的时候JVM会只产生一个StringBuilder并连续append等号后面的字符串。 不过上面的例子要注意一点，因为”111″、”222″、”333″、”444″都是编译期间即可得知的常量，因为第5行的代码JVM在编译的时候并不会生成一个StringBuilder而是直接生成字符串”111222333444″。 但是这么写得很少，主要原因有两点： 例子比较简单，但实际上大量的“+”会导致代码的可读性非常差 待拼接的内容可能从各种地方获取，比如调用接口、从.properties文件中、从.xml文件中，这样的场景下尽管用多个“+”的方式也不是不可以，但会让代码维护性不太好]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决oracle 1521端口,本机127.0.0.1可通,其他ip不通]]></title>
    <url>%2F2017%2F06%2F02%2F2017-06-02-001%2F</url>
    <content type="text"><![CDATA[问题我的环境是oracle11gr2，本地用plsql还是toad连接都没有任何问题，而用别的机器远程连接就提示 无监听程序等错误。 原因oracle安装路径 — 例如：F:\app\Administrator\product\11.2.0\dbhome_1\NETWORK\ADMIN下面的listener.ora和tnsnames.ora这两个文件 打开看一下 数据库时，本地可以连，而远程连接不了！ 解决办法将上面两个文件中 高亮的localhost全部替换成本机的计算机名。 然后重新启动oralce服务 和监听就可以了。]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
</search>