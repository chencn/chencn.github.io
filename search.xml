<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SPRING 教程]]></title>
    <url>%2F2017%2F06%2F13%2F2017-06-17-spring%2F</url>
    <content type="text"><![CDATA[SPRING 教程适用于忘记配置是Ctrl + C /Ctrl + V IOC/DISpring是一个基于IOC和AOP的结构J2EE系统的框架IOC 反转控制 是Spring的基础，Inversion Of Control简单说就是创建对象由以前的程序员自己new 构造方法来调用，变成了交由Spring创建对象DI 依赖注入 Dependency Inject. 简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可 pojo准备pojo Category，用来演示IOC和DI 12345678910111213141516171819package com.xqchen.pojo; public class Category &#123; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; private int id; private String name;&#125; applicationContext.xml在src目录下新建applicationContext.xml文件applicationContext.xml是Spring的核心配置文件，通过关键字c即可获取Category对象，该对象获取的时候，即被注入了字符串”category 1“到name属性中 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!--注入的bean --&gt; &lt;bean name="c" class="com.xqchen.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt; &lt;/beans&gt; TestSpring测试代码，演示通过spring获取Category对象，以及该对象被注入的name属性。如图所示，可以打印出通过Spring拿到的Category对象的name属性 123456789101112131415161718package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.pojo.Category; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext( new String[] &#123; "applicationContext.xml" &#125;); Category c = (Category) context.getBean("c"); System.out.println(c.getName()); &#125;&#125; 原理图以获取对象的方式来进行比较 传统的方式：通过new 关键字主动创建一个对象IOC方式对象的生命周期由Spring来管理，直接从Spring那里去获取一个对象。 IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。 打个比喻：传统方式：相当于你自己去菜市场new 了一直鸡，但是是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。用 IOC：相当于去馆子(Spring)点了一直 鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。 注入对象在上例中，对Category的name属性注入了”category 1”字符串在本例中 ，对Product对象，注入一个Category对象 Product.javaProduct类中有对Category对象的setter getter1234567891011121314151617181920212223242526package com.xqchen.pojo; public class Product &#123; private int id; private String name; private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; applicationContext.xml在创建Product的时候注入一个Category对象注意，这里要使用ref来注入另一个对象 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;bean name="c" class="com.xqchen.pojo.Category"&gt; &lt;property name="name" value="category 1" /&gt; &lt;/bean&gt; &lt;bean name="p" class="com.xqchen.pojo.Product"&gt; &lt;property name="name" value="product1" /&gt; &lt;!-- --&gt; &lt;property name="category" ref="c" /&gt; &lt;/bean&gt;&lt;/beans&gt; TestSpring通过Spring拿到的Product对象已经被注入了Category对象了 123456789101112131415161718 package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.pojo.Product; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123; "applicationContext.xml" &#125;); Product p = (Product) context.getBean("p"); System.out.println(p.getName()); System.out.println(p.getCategory().getName()); &#125;&#125; 注解方式 IOC/DI修改applicationContext.xml 添加 ```12345678910111213141516171819202122232425262728293031 表示告诉Spring要用注解的方式进行配置2. 注入对象category 注释掉，这个行为在后面将使用注解来完成```java&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt; &lt;context:annotation-config/&gt; &lt;bean name=&quot;c&quot; class=&quot;com.xqchen.pojo.Category&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;category 1&quot; /&gt; &lt;/bean&gt; &lt;bean name=&quot;p&quot; class=&quot;com.xqchen.pojo.Product&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;product1&quot; /&gt;&lt;!-- &lt;property name=&quot;category&quot; ref=&quot;c&quot; /&gt; --&gt; &lt;/bean&gt; &lt;/beans&gt; @Autowired在Product.java的category属性前加上@Autowired注解 12@Autowiredprivate Category category; 1234567891011121314151617181920212223242526272829303132333435package com.xqchen.pojo; import org.springframework.beans.factory.annotation.Autowired; public class Product &#123; private int id; private String name; @Autowired private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; 运行测试 12345678910111213141516package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.pojo.Product; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123; "applicationContext.xml" &#125;); Product p = (Product) context.getBean("p"); System.out.println(p.getName()); System.out.println(p.getCategory().getName()); &#125;&#125; @Autowired的位置除了前面的 在属性前加上@Autowired 这种方式外，也可以在setCategory方法前加上@Autowired，这样来达到相同的效果 12@Autowiredpublic void setCategory(Category category) 1234567891011121314151617181920212223242526272829303132333435package com.xqchen.pojo; import org.springframework.beans.factory.annotation.Autowired; public class Product &#123; private int id; private String name; private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; @Autowired public void setCategory(Category category) &#123; this.category = category; &#125;&#125; @Resource除了@Autowired之外，@Resource也是常用的手段 12@Resource(name="c")private Category category; 1234567891011121314151617181920212223242526272829303132333435package com.xqchen.pojo; import javax.annotation.Resource; public class Product &#123; private int id; private String name; @Resource(name="c") private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; 对Bean的注解上述例子是对注入对象行为的注解，那么bean对象本身，比如Category,Product可不可以移出applicationContext.xml配置文件，也通过注解进行呢？接下来就讲解如何对Bean进行注解配置 applicationContext.xml修改applicationContext.xml，什么都去掉，只新增： 1&lt;context:component-scan base-package="com.xqchen.pojo"/&gt; 其作用是告诉Spring，bean都放在com.xqchen.pojo这个包下 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;context:component-scan base-package="com.xqchen.pojo"/&gt; &lt;/beans&gt; @Component为Product类加上@Component注解，即表明此类是bean 12@Component("p")public class Product &#123; 为Category 类加上@Component注解，即表明此类是bean 12 @Component("c")public class Category &#123; 另外，因为配置从applicationContext.xml中移出来了，所以属性初始化放在属性声明上进行了。 12private String name="product 1";private String name="category 1"; Product.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.xqchen.pojo; import javax.annotation.Resource; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component; @Component("p")public class Product &#123; private int id; private String name="product 1"; @Autowired private Category category; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; Category.java12345678910111213141516171819202122package com.xqchen.pojo; import org.springframework.stereotype.Component; @Component("c")public class Category &#123; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; private int id; private String name="category 1";&#125; 运行测试 12345678910111213141516package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.pojo.Product; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123; "applicationContext.xml" &#125;); Product p = (Product) context.getBean("p"); System.out.println(p.getName()); System.out.println(p.getCategory().getName()); &#125;&#125; AOP 面向切面编程AOP 即 Aspect Oriental Program 面向切面编程首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务所谓的周边功能，比如性能统计，日志，事务管理等等 周边功能在Spring的变相切面编程AOP思想里，即被定义为切面 在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发 然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP 思路图 功能分两大类，辅助功能和核心业务功能 辅助功能和核心业务功能彼此独立进行开发 比如登陆功能，即便是没有性能统计和日志输出，也可以正常运行 如果有需要，就把”日志输出” 功能和 “登陆” 功能 编织在一起，这样登陆的时候，就可以看到日志输出了 辅助功能，又叫做切面，这种能够选择性的，低耦合的把切面和核心业务功能结合在一起的编程思想，就叫做切面编程 准备业务类 ProductService1234567891011package com.xqchen.service; public class ProductService &#123; public void doSomeService()&#123; System.out.println("doSomeService"); &#125; &#125; TestSpring在引入切面之前，调用该业务类 123456789101112131415package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.service.ProductService; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123; "applicationContext.xml" &#125;); ProductService s = (ProductService) context.getBean("s"); s.doSomeService(); &#125;&#125; 准备日志切面 LoggerAspect该日志切面的功能是 在调用核心功能之前和之后分别打印日志，切面就是原理图中讲的那些辅助功能。 object = joinPoint.proceed(); ```12345678910111213141516就是将来与某个核心功能编织之后，用于执行核心功能的代码```javapackage com.xqchen.aspect;import org.aspectj.lang.ProceedingJoinPoint; public class LoggerAspect &#123; public Object log(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;start log:&quot; + joinPoint.getSignature().getName()); Object object = joinPoint.proceed(); System.out.println(&quot;end log:&quot; + joinPoint.getSignature().getName()); return object; &#125;&#125; applicationContext.xml12&lt;bean name=&quot;s&quot; class=&quot;com.xqchen.service.ProductService&quot;&gt;&lt;/bean&gt; 声明业务对象 1&lt;bean id=&quot;loggerAspect&quot; class=&quot;com.xqchen.aspect.LoggerAspect&quot;/&gt; 声明日志切面 结合思路图 123&lt;aop:pointcut id=&quot;loggerCutpoint&quot; expression= &quot;execution(* com.xqchen.service.ProductService.*(..)) &quot;/&gt; 指定右边的核心业务功能 123&lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;loggerAspect&quot;&gt; &lt;aop:around pointcut-ref=&quot;loggerCutpoint&quot; method=&quot;log&quot;/&gt; &lt;/aop:aspect&gt; 指定左边的辅助功能然后通过aop:config把业务对象与辅助功能编织在一起。 1execution(* com.xqchen.service.ProductService.*(..)) 这表示对满足如下条件的方法调用，进行切面操作：返回任意类型 com.xqchen.service.ProductService.* 包名以 com.xqchen.service.ProductService 开头的类的任意方法(..) 参数是任意数量和类型 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;bean name="c" class="com.xqchen.pojo.Category"&gt; &lt;property name="name" value="yyy" /&gt; &lt;/bean&gt; &lt;bean name="p" class="com.xqchen.pojo.Product"&gt; &lt;property name="name" value="product1" /&gt; &lt;property name="category" ref="c" /&gt; &lt;/bean&gt; &lt;bean name="s" class="com.xqchen.service.ProductService"&gt; &lt;/bean&gt; &lt;bean id="loggerAspect" class="com.xqchen.aspect.LoggerAspect"/&gt; &lt;aop:config&gt; &lt;aop:pointcut id="loggerCutpoint" expression= "execution(* com.xqchen.service.ProductService.*(..)) "/&gt; &lt;aop:aspect id="logAspect" ref="loggerAspect"&gt; &lt;aop:around pointcut-ref="loggerCutpoint" method="log"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;/beans&gt; TestSpringTestSpring 代码没有发生任何变化，通过配置的方式，把切面和核心业务类编制在了一起。 运行测试，可以发现在编织之后，业务方法运行之前和之后分别会打印日志 12345678910111213141516package com.xqchen.test; import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext; import com.xqchen.service.ProductService; public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext( new String[] &#123; "applicationContext.xml" &#125;); ProductService s = (ProductService) context.getBean("s"); s.doSomeService(); &#125;&#125; 注解方式 AOP本章节把XML方式配置AOP 改造为注解方式 注解配置业务类使用@Component(“s”) 注解ProductService 类 1234567891011package com.xqchen.service; import org.springframework.stereotype.Component; @Component("s")public class ProductService &#123; public void doSomeService()&#123; System.out.println("doSomeService"); &#125; &#125; 注解配置切面123@Aspect 注解表示这是一个切面@Component 表示这是一个bean,由Spring进行管理@Around(value = &quot;execution(* com.xqchen.service.ProductService.*(..))&quot;) 表示对com.xqchen.service.ProductService 这个类中的所有方法进行切面操作 123456789101112131415161718package com.xqchen.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component; @Aspect@Componentpublic class LoggerAspect &#123; @Around(value = "execution(* com.xqchen.service.ProductService.*(..))") public Object log(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println("start log:" + joinPoint.getSignature().getName()); Object object = joinPoint.proceed(); System.out.println("end log:" + joinPoint.getSignature().getName()); return object; &#125;&#125; applicationContext.xml去掉原有信息，添加如下3行 12&lt;context:component-scan base-package=&quot;com.xqchen.aspect&quot;/&gt;&lt;context:component-scan base-package=&quot;com.xqchen.service&quot;/&gt; 扫描包com.xqchen.aspect和com.xqchen.service，定位业务类和切面类```123456789101112131415161718192021222324找到被注解了的切面类，进行切面配置```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.xqchen.aspect&quot;/&gt; &lt;context:component-scan base-package=&quot;com.xqchen.service&quot;/&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; 运行测试 SPRING MVC待更新 注解方式测试jar注解方式用到了junit,所以需要下载:junit-4.12.jar和hamcrest-all-1.3.jar并导入到当前项目中。 TestSpring修改TestSpring, 并运行 @RunWith(SpringJUnit4ClassRunner.class)表示这是一个Spring的测试类 @ContextConfiguration(“classpath:applicationContext.xml”)定位Spring的配置文件 @Autowired给这个测试类装配Category对象 @Test测试逻辑，打印c对象的名称 123456789101112131415161718192021package com.xqchen.test; import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.xqchen.pojo.Category; @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class TestSpring &#123; @Autowired Category c; @Test public void test()&#123; System.out.println(c.getName()); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用maven创建web项目]]></title>
    <url>%2F2017%2F06%2F05%2F2017-06-05-002%2F</url>
    <content type="text"><![CDATA[首先新建一个maven项目，看图： ##按照以上步骤就可以创建一个maven项目，可以看到最下图的目录结构**，但是这样的目录结构是不对的，需要做一些修改。 首先为了避免乱码，我们应该将项目编码换成UTF-8，以后项目编码都采用UTF-8，加个字符编码过滤器，乱码就不再“乱”了（不表示没有，但是比较容易解决）。 再次，按照以下图解来进行操作（设置JRE为默认的），这样就会出现完整的、正确的目录结构 最后，还有个index.jsp报错，我们需要引入Java ee的jar包即可。在pom.xml中引入： 123456&lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; 至此，完整的目录结构以及正确的项目搞定了。接下来再进行一些配置，毕竟是web项目，需要jstl等等，配置如下： 注: 如果报错 cannot change version web module 3.0 请参阅 百度经验]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 三种实例化bean的方式]]></title>
    <url>%2F2017%2F06%2F05%2F2017-06-05-001%2F</url>
    <content type="text"><![CDATA[在spring中有三中实例化bean的方式： 使用构造器实例化；(通常使用的一个方法) 使用静态工厂方法实例化； 使用实例化工厂方法实例化。 使用构造器实例化当你使用构造方法来创建bean的时候，Spring对class没有特殊的要求。也就是说，正在开发的类不需要实现任何特定的接口或者以特定的方式进行编码。但是，根据你使用那种类型的IoC来指定bean，你可能需要一个默认（无参）的构造方法。 Spring IoC 容器可以管理几乎所有你想让它管理的类，它不限于管理POJO。大多数Spring用户更喜欢使用POJO（一个默认无参的构造方法和setter,getter方法）。但在容器中使用非bean形式(non-bean style)的类也是可以的。比如遗留系统中的连接池，很显然它与JavaBean规范不符，但Spring也能管理它。 当使用基于XML的元数据配置文件，可以这样来指定bean类：123&lt;!--spring.xml配置：--&gt; &lt;bean id="exampleBean" class="examples.ExampleBean"/&gt; id是对象的名称，class是要实例化的类，然后再通过正常的方式进调用实例化的类即可，例如： 12345678public void ExampleBean()&#123; //加载spring配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(new String[]&#123;"/conf/spring.xml"&#125;); //调用getBean方法取得被实例化的对象。 exampleBean eb = (exampleBean) ac.getBean("exampleBean"); eb.save(); &#125; 采用这种实例化方式要注意的是：要实例化的类中如果有构造器的话，一定要有一个无参的构造器。 使用静态工厂方法实例化使用静态工厂方法进行实例化就要具备两个条件： 要有工厂类及其工厂方法； 工厂方法是静态的。 首先创建工程类及其静态方法： 12345678public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125;&#125; 然后再去配置spring配置文件：当采用静态工厂方法创建bean时，除了需要指定class属性外，还需要通过factory-method属性来指定创建bean实例的工厂方法。Spring将调用此方法(其可选参数接下来介绍)返回实例对象，就此而言，跟通过普通构造器创建类实例没什么两样。 下面的bean定义展示了如何通过工厂方法来创建bean实例。注意，此定义并未指定返回对象的类型，仅指定该类包含的工厂方法。在此例中，createInstance()必须是一个static方法。 1&lt;bean id="clientService" class="examples.ClientService" factory-method="createInstance"/&gt; 注: id是实例化的对象的名称，class是工厂类，也就实现实例化类的静态方法所属的类，factory-method是实现实例化类的静态方法。 然后按照正常的调用方法去调用即可： 使用实例化工厂方法实例化与通过 静态工厂方法 实例化类似，通过调用工厂实例的非静态方法进行实例化。 使用这种方式时，class属性必须为空，而factory-bean属性必须指定为当前(或其祖先)容器中包含工厂方法的bean的名称，而该工厂bean的工厂方法本身必须通过factory-method属性来设定。123456789&lt;!-- 工厂bean，包含createInstance()方法 --&gt;&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- 其他需要注入的依赖项 --&gt;&lt;/bean&gt;&lt;!-- 通过工厂bean创建的ben --&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt; 123456789public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private DefaultServiceLocator() &#123;&#125; public ClientService createClientServiceInstance() &#123; return clientService; &#125;&#125; 一个工厂类也可以有多个工厂方法，如下代码所示：1234567891011&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- 其他需要注入的依赖项 --&gt;&lt;/bean&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt;&lt;bean id="accountService" factory-bean="serviceLocator" factory-method="createAccountServiceInstance"/&gt; 12345678910111213141516public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); private DefaultServiceLocator() &#123;&#125; public ClientService createClientServiceInstance() &#123; return clientService; &#125; public AccountService createAccountServiceInstance() &#123; return accountService; &#125;&#125; 这种做法表明工厂bean本身也可以通过依赖注入（DI）进行管理配置。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从为什么 String=String 谈到 StringBuilder 和 StringBuffer]]></title>
    <url>%2F2017%2F06%2F04%2F2017-06-04-001%2F</url>
    <content type="text"><![CDATA[前言有这么一段代码：123456789public class TestMain&#123; public static void main(String[] args) &#123; String str0 = "123"; String str1 = "123"; System.out.println(str0 == str1); &#125;&#125; 运行结果是什么？答案当然是true。对，答案的确是true，但是这是为什么呢？很多人第一反应肯定是两个”123″的String当然相等啊，这还要想。但是”==”在Java比较的不是两个对象的值，而是比较两个对象的引用是否相等，和两个String都是”123″又有什么关系呢？或者我们把程序修改一下123456789public class TestMain&#123; public static void main(String[] args) &#123; String str2 = new String("234"); String str3 = new String("234"); System.out.println(str2 == str3); &#125;&#125; 这时候运行结果就是false了，因为尽管两个String对象都是”234″，但是str2和str3是两个不同的引用，所以返回的false。OK，围绕第一段代码返回true，第二段代码返回false，开始文章的内容。 为什么String=String？在JVM中有一块区域叫做常量池，关于常量池，可以参考这篇文章：Java内存区域及对象常量池中的数据是那些在编译期间被确定，并被保存在已编译的.class文件中的一些数据。除了包含所有的8种基本数据类型（char、byte、short、int、long、float、double、boolean）外，还有String及其数组的常量值，另外还有一些以文本形式出现的符号引用。 Java栈的特点是存取速度快（比堆块），但是空间小，数据生命周期固定，只能生存到方法结束。我们定义的 boolean b = true、char c = ‘c’、String str = “123” ，这些语句，我们拆分为几部分来看： true、c、123，这些等号右边的指的是编译期间可以被确定的内容，都被维护在常量池中 b、c、str这些等号左边第一个出现的指的是一个引用，引用的内容是等号右边数据在常量池中的地址 boolean、char、String这些是引用的类型 栈有一个特点，就是数据共享。回到我们第一个例子，第五行String str0 = “123″，编译的时候，在常量池中创建了一个常量”123″，然后走第六行String str1 = “123″，先去常量池中找有没有这个”123″，发现有，str1也指向常量池中的”123″，所以第七行的str0 == str1返回的是true，因为str0和str1指向的都是常量池中的”123″这个字符串的地址。当然如果String str1 = “234″，就又不一样了，因为常量池中没有”234″，所以会在常量池中创建一个”234″，然后str1代表的是这个”234″的地址。分析了String，其实其他基本数据类型也都是一样的：先看常量池中有没有要创建的数据，有就返回数据的地址，没有就创建一个。 第二个例子呢？Java虚拟机的解释器每遇到一个new关键字，都会在堆内存中开辟一块内存来存放一个String对象，所以str2、str3指向的堆内存中虽然存储的是相等的”234″，但是由于是两块不同的堆内存，因此str2 == str3返回的仍然是false，网上找到一张图表示一下这个概念： 为什么要使用StringBuilder和StringBuffer拼接字符串？ 大家在开发中一定有一个原则是”利用StringBuilder和StringBuffer拼接字符串”，但是为什么呢？用一段代码来分析一下： 123456789 public class StringTest &#123; @Test public void testStringPlus() &#123; String str = "111"; str += "222"; str += "333"; System.out.println(str); &#125; &#125; 这段代码，我们找到编译后的StringTest.class文件，使用”javap -verbose StringTest”或者”javap -c StringTest”都可以，反编译一下class获取到对应的字节码： 123456789101112131415161718192021222324252627 public void testStringPlus(); Code: 0: ldc #2 // String 111 2: astore_1 3: new #3 // class java/lang/StringBuilder 6: dup 7: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 10: aload_1 11: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 14: ldc #6 // String 222 16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokevirtual #7 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 22: astore_1 23: new #3 // class java/lang/StringBuilder 26: dup 27: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 30: aload_1 31: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 34: ldc #8 // String 333 36: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 39: invokevirtual #7 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 42: astore_1 43: getstatic #9 // Field java/lang/System.out:Ljava/io/PrintStream; 46: aload_1 47: invokevirtual #10 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 50: return&#125; 这段字节码不用看得很懂，大致上能明白就好，意思很明显：编译器每次碰到”+”的时候，会new一个StringBuilder出来，接着调用append方法，在调用toString方法，生成新字符串。那么，这意味着，如果代码中有很多的”+”，就会每个”+”生成一次StringBuilder，这种方式对内存是一种浪费，效率很不好。 在Java中还有一种拼接字符串的方式，就是String的concat方法，其实这种方式拼接字符串也不是很好，具体原因看一下concat方法的实现： 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);&#125; 意思就是通过两次字符串的拷贝，产生一个新的字符数组buf[]，再根据字符数组buf[]，new一个新的String对象出来，这意味着concat方法调用N次，将发生N*2次数组拷贝以及new出N个String对象，无论对于时间还是空间都是一种浪费。 根据上面的解读，由于”+”拼接字符串与String的concat方法拼接字符串的低效，我们才需要使用StringBuilder和StringBuffer来拼接字符串。以StringBuilder为例：123456789101112public class TestMain&#123; public static void main(String[] args) &#123; StringBuilder sb = new StringBuilder("111"); sb.append("222"); sb.append("111"); sb.append("111"); sb.append("444"); System.out.println(sb.toString()); &#125;&#125; StringBuffer和StringBuilder原理一样，无非是在底层维护了一个char数组，每次append的时候就往char数组里面放字符而已，在最终sb.toString()的时候，用一个new String()方法把char数组里面的内容都转成String，这样，整个过程中只产生了一个StringBuilder对象与一个String对象，非常节省空间。StringBuilder唯一的性能损耗点在于char数组不够的时候需要进行扩容，扩容需要进行数组拷贝，一定程度上降低了效率。 StringBuffer和StringBuilder用法一模一样，唯一的区别只是StringBuffer是线程安全的，它对所有方法都做了同步，StringBuilder是线程非安全的，所以在不涉及线程安全的场景，比如方法内部，尽量使用StringBuilder，避免同步带来的消耗。 另外，StringBuffer和StringBuilder还有一个优化点，上面说了，扩容的时候有性能上的损耗，那么如果可以估计到要拼接的字符串的长度的话，尽量利用构造函数指定他们的长度。 真的不能用”+”拼接字符串？虽然说不要用”+”拼接字符串，因为会产生大量的无用StringBuilder对象，但也不是不可以，比如可以使用以下的方式： 12345678public class TestMain&#123; public static void main(String[] args) &#123; String str = "111" + "222" + "333" + "444"; System.out.println(str); &#125;&#125; 就这种连续+的情况，实际上编译的时候JVM会只产生一个StringBuilder并连续append等号后面的字符串。 不过上面的例子要注意一点，因为”111″、”222″、”333″、”444″都是编译期间即可得知的常量，因为第5行的代码JVM在编译的时候并不会生成一个StringBuilder而是直接生成字符串”111222333444″。 但是这么写得很少，主要原因有两点： 例子比较简单，但实际上大量的“+”会导致代码的可读性非常差 待拼接的内容可能从各种地方获取，比如调用接口、从.properties文件中、从.xml文件中，这样的场景下尽管用多个“+”的方式也不是不可以，但会让代码维护性不太好]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决oracle 1521端口,本机127.0.0.1可通,其他ip不通]]></title>
    <url>%2F2017%2F06%2F02%2F2017-06-02-001%2F</url>
    <content type="text"><![CDATA[问题我的环境是oracle11gr2，本地用plsql还是toad连接都没有任何问题，而用别的机器远程连接就提示 无监听程序等错误。 原因oracle安装路径 — 例如：F:\app\Administrator\product\11.2.0\dbhome_1\NETWORK\ADMIN下面的listener.ora和tnsnames.ora这两个文件 打开看一下 数据库时，本地可以连，而远程连接不了！ 解决办法将上面两个文件中 高亮的localhost全部替换成本机的计算机名。 然后重新启动oralce服务 和监听就可以了。]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
</search>