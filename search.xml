<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring 三种实例化bean的方式]]></title>
    <url>%2F2017%2F06%2F05%2F2017-06-05-001%2F</url>
    <content type="text"><![CDATA[在spring中有三中实例化bean的方式： 使用构造器实例化；(通常使用的一个方法) 使用静态工厂方法实例化； 使用实例化工厂方法实例化。 使用构造器实例化当你使用构造方法来创建bean的时候，Spring对class没有特殊的要求。也就是说，正在开发的类不需要实现任何特定的接口或者以特定的方式进行编码。但是，根据你使用那种类型的IoC来指定bean，你可能需要一个默认（无参）的构造方法。 Spring IoC 容器可以管理几乎所有你想让它管理的类，它不限于管理POJO。大多数Spring用户更喜欢使用POJO（一个默认无参的构造方法和setter,getter方法）。但在容器中使用非bean形式(non-bean style)的类也是可以的。比如遗留系统中的连接池，很显然它与JavaBean规范不符，但Spring也能管理它。 当使用基于XML的元数据配置文件，可以这样来指定bean类：123&lt;!--spring.xml配置：--&gt; &lt;bean id="exampleBean" class="examples.ExampleBean"/&gt; id是对象的名称，class是要实例化的类，然后再通过正常的方式进调用实例化的类即可，例如： 12345678public void ExampleBean()&#123; //加载spring配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(new String[]&#123;"/conf/spring.xml"&#125;); //调用getBean方法取得被实例化的对象。 exampleBean eb = (exampleBean) ac.getBean("exampleBean"); eb.save(); &#125; 采用这种实例化方式要注意的是：要实例化的类中如果有构造器的话，一定要有一个无参的构造器。 使用静态工厂方法实例化使用静态工厂方法进行实例化就要具备两个条件： 要有工厂类及其工厂方法； 工厂方法是静态的。 首先创建工程类及其静态方法： 12345678public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125;&#125; 然后再去配置spring配置文件：当采用静态工厂方法创建bean时，除了需要指定class属性外，还需要通过factory-method属性来指定创建bean实例的工厂方法。Spring将调用此方法(其可选参数接下来介绍)返回实例对象，就此而言，跟通过普通构造器创建类实例没什么两样。 下面的bean定义展示了如何通过工厂方法来创建bean实例。注意，此定义并未指定返回对象的类型，仅指定该类包含的工厂方法。在此例中，createInstance()必须是一个static方法。 1&lt;bean id="clientService" class="examples.ClientService" factory-method="createInstance"/&gt; 注: id是实例化的对象的名称，class是工厂类，也就实现实例化类的静态方法所属的类，factory-method是实现实例化类的静态方法。 然后按照正常的调用方法去调用即可： 使用实例化工厂方法实例化与通过 静态工厂方法 实例化类似，通过调用工厂实例的非静态方法进行实例化。 使用这种方式时，class属性必须为空，而factory-bean属性必须指定为当前(或其祖先)容器中包含工厂方法的bean的名称，而该工厂bean的工厂方法本身必须通过factory-method属性来设定。123456789&lt;!-- 工厂bean，包含createInstance()方法 --&gt;&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- 其他需要注入的依赖项 --&gt;&lt;/bean&gt;&lt;!-- 通过工厂bean创建的ben --&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt; 123456789public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private DefaultServiceLocator() &#123;&#125; public ClientService createClientServiceInstance() &#123; return clientService; &#125;&#125; 一个工厂类也可以有多个工厂方法，如下代码所示：1234567891011&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- 其他需要注入的依赖项 --&gt;&lt;/bean&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt;&lt;bean id="accountService" factory-bean="serviceLocator" factory-method="createAccountServiceInstance"/&gt; 12345678910111213141516public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); private DefaultServiceLocator() &#123;&#125; public ClientService createClientServiceInstance() &#123; return clientService; &#125; public AccountService createAccountServiceInstance() &#123; return accountService; &#125;&#125; 这种做法表明工厂bean本身也可以通过依赖注入（DI）进行管理配置。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用maven创建web项目]]></title>
    <url>%2F2017%2F06%2F05%2F2017-06-05-002%2F</url>
    <content type="text"><![CDATA[首先新建一个maven项目，看图： ##按照以上步骤就可以创建一个maven项目，可以看到最下图的目录结构**，但是这样的目录结构是不对的，需要做一些修改。 首先为了避免乱码，我们应该将项目编码换成UTF-8，以后项目编码都采用UTF-8，加个字符编码过滤器，乱码就不再“乱”了（不表示没有，但是比较容易解决）。 再次，按照以下图解来进行操作（设置JRE为默认的），这样就会出现完整的、正确的目录结构 最后，还有个index.jsp报错，我们需要引入Java ee的jar包即可。在pom.xml中引入： 123456&lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; 至此，完整的目录结构以及正确的项目搞定了。接下来再进行一些配置，毕竟是web项目，需要jstl等等，配置如下： 注 关于报错 cannot change version web module 3.0 请参阅 百度经验]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从为什么 String=String 谈到 StringBuilder 和 StringBuffer]]></title>
    <url>%2F2017%2F06%2F04%2F2017-06-04-001%2F</url>
    <content type="text"><![CDATA[前言有这么一段代码：123456789public class TestMain&#123; public static void main(String[] args) &#123; String str0 = "123"; String str1 = "123"; System.out.println(str0 == str1); &#125;&#125; 运行结果是什么？答案当然是true。对，答案的确是true，但是这是为什么呢？很多人第一反应肯定是两个”123″的String当然相等啊，这还要想。但是”==”在Java比较的不是两个对象的值，而是比较两个对象的引用是否相等，和两个String都是”123″又有什么关系呢？或者我们把程序修改一下123456789public class TestMain&#123; public static void main(String[] args) &#123; String str2 = new String("234"); String str3 = new String("234"); System.out.println(str2 == str3); &#125;&#125; 这时候运行结果就是false了，因为尽管两个String对象都是”234″，但是str2和str3是两个不同的引用，所以返回的false。OK，围绕第一段代码返回true，第二段代码返回false，开始文章的内容。 为什么String=String？在JVM中有一块区域叫做常量池，关于常量池，可以参考这篇文章：Java内存区域及对象常量池中的数据是那些在编译期间被确定，并被保存在已编译的.class文件中的一些数据。除了包含所有的8种基本数据类型（char、byte、short、int、long、float、double、boolean）外，还有String及其数组的常量值，另外还有一些以文本形式出现的符号引用。 Java栈的特点是存取速度快（比堆块），但是空间小，数据生命周期固定，只能生存到方法结束。我们定义的 boolean b = true、char c = ‘c’、String str = “123” ，这些语句，我们拆分为几部分来看： true、c、123，这些等号右边的指的是编译期间可以被确定的内容，都被维护在常量池中 b、c、str这些等号左边第一个出现的指的是一个引用，引用的内容是等号右边数据在常量池中的地址 boolean、char、String这些是引用的类型 栈有一个特点，就是数据共享。回到我们第一个例子，第五行String str0 = “123″，编译的时候，在常量池中创建了一个常量”123″，然后走第六行String str1 = “123″，先去常量池中找有没有这个”123″，发现有，str1也指向常量池中的”123″，所以第七行的str0 == str1返回的是true，因为str0和str1指向的都是常量池中的”123″这个字符串的地址。当然如果String str1 = “234″，就又不一样了，因为常量池中没有”234″，所以会在常量池中创建一个”234″，然后str1代表的是这个”234″的地址。分析了String，其实其他基本数据类型也都是一样的：先看常量池中有没有要创建的数据，有就返回数据的地址，没有就创建一个。 第二个例子呢？Java虚拟机的解释器每遇到一个new关键字，都会在堆内存中开辟一块内存来存放一个String对象，所以str2、str3指向的堆内存中虽然存储的是相等的”234″，但是由于是两块不同的堆内存，因此str2 == str3返回的仍然是false，网上找到一张图表示一下这个概念： 为什么要使用StringBuilder和StringBuffer拼接字符串？ 大家在开发中一定有一个原则是”利用StringBuilder和StringBuffer拼接字符串”，但是为什么呢？用一段代码来分析一下： 123456789 public class StringTest &#123; @Test public void testStringPlus() &#123; String str = "111"; str += "222"; str += "333"; System.out.println(str); &#125; &#125; 这段代码，我们找到编译后的StringTest.class文件，使用”javap -verbose StringTest”或者”javap -c StringTest”都可以，反编译一下class获取到对应的字节码： 123456789101112131415161718192021222324252627 public void testStringPlus(); Code: 0: ldc #2 // String 111 2: astore_1 3: new #3 // class java/lang/StringBuilder 6: dup 7: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 10: aload_1 11: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 14: ldc #6 // String 222 16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokevirtual #7 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 22: astore_1 23: new #3 // class java/lang/StringBuilder 26: dup 27: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 30: aload_1 31: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 34: ldc #8 // String 333 36: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 39: invokevirtual #7 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 42: astore_1 43: getstatic #9 // Field java/lang/System.out:Ljava/io/PrintStream; 46: aload_1 47: invokevirtual #10 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 50: return&#125; 这段字节码不用看得很懂，大致上能明白就好，意思很明显：编译器每次碰到”+”的时候，会new一个StringBuilder出来，接着调用append方法，在调用toString方法，生成新字符串。那么，这意味着，如果代码中有很多的”+”，就会每个”+”生成一次StringBuilder，这种方式对内存是一种浪费，效率很不好。 在Java中还有一种拼接字符串的方式，就是String的concat方法，其实这种方式拼接字符串也不是很好，具体原因看一下concat方法的实现： 12345678910public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);&#125; 意思就是通过两次字符串的拷贝，产生一个新的字符数组buf[]，再根据字符数组buf[]，new一个新的String对象出来，这意味着concat方法调用N次，将发生N*2次数组拷贝以及new出N个String对象，无论对于时间还是空间都是一种浪费。 根据上面的解读，由于”+”拼接字符串与String的concat方法拼接字符串的低效，我们才需要使用StringBuilder和StringBuffer来拼接字符串。以StringBuilder为例：123456789101112public class TestMain&#123; public static void main(String[] args) &#123; StringBuilder sb = new StringBuilder("111"); sb.append("222"); sb.append("111"); sb.append("111"); sb.append("444"); System.out.println(sb.toString()); &#125;&#125; StringBuffer和StringBuilder原理一样，无非是在底层维护了一个char数组，每次append的时候就往char数组里面放字符而已，在最终sb.toString()的时候，用一个new String()方法把char数组里面的内容都转成String，这样，整个过程中只产生了一个StringBuilder对象与一个String对象，非常节省空间。StringBuilder唯一的性能损耗点在于char数组不够的时候需要进行扩容，扩容需要进行数组拷贝，一定程度上降低了效率。 StringBuffer和StringBuilder用法一模一样，唯一的区别只是StringBuffer是线程安全的，它对所有方法都做了同步，StringBuilder是线程非安全的，所以在不涉及线程安全的场景，比如方法内部，尽量使用StringBuilder，避免同步带来的消耗。 另外，StringBuffer和StringBuilder还有一个优化点，上面说了，扩容的时候有性能上的损耗，那么如果可以估计到要拼接的字符串的长度的话，尽量利用构造函数指定他们的长度。 真的不能用”+”拼接字符串？虽然说不要用”+”拼接字符串，因为会产生大量的无用StringBuilder对象，但也不是不可以，比如可以使用以下的方式： 12345678public class TestMain&#123; public static void main(String[] args) &#123; String str = "111" + "222" + "333" + "444"; System.out.println(str); &#125;&#125; 就这种连续+的情况，实际上编译的时候JVM会只产生一个StringBuilder并连续append等号后面的字符串。 不过上面的例子要注意一点，因为”111″、”222″、”333″、”444″都是编译期间即可得知的常量，因为第5行的代码JVM在编译的时候并不会生成一个StringBuilder而是直接生成字符串”111222333444″。 但是这么写得很少，主要原因有两点： 例子比较简单，但实际上大量的“+”会导致代码的可读性非常差 待拼接的内容可能从各种地方获取，比如调用接口、从.properties文件中、从.xml文件中，这样的场景下尽管用多个“+”的方式也不是不可以，但会让代码维护性不太好]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决oracle 1521端口,本机127.0.0.1可通,其他ip不通]]></title>
    <url>%2F2017%2F06%2F02%2F2017-06-02-001%2F</url>
    <content type="text"><![CDATA[问题我的环境是oracle11gr2，本地用plsql还是toad连接都没有任何问题，而用别的机器远程连接就提示 无监听程序等错误。 原因oracle安装路径 — 例如：F:\app\Administrator\product\11.2.0\dbhome_1\NETWORK\ADMIN下面的listener.ora和tnsnames.ora这两个文件 打开看一下 数据库时，本地可以连，而远程连接不了！ 解决办法将上面两个文件中 高亮的localhost全部替换成本机的计算机名。 然后重新启动oralce服务 和监听就可以了。]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
</search>